* Initial config
** Emacs server
Start Emacs server.
#+begin_src emacs-lisp
 (server-start)
#+end_src
** Sensitive information
Load information I don't want to be publicly available – for one reason or another – from a separate file.
#+begin_src emacs-lisp
(load "~/Dropbox/.emacs.secrets.el")
#+end_src
** Packages configuration
Set package repositories.
#+begin_src emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))
  (package-initialize)
  (add-to-list 'load-path
               "~/.emacs.d/elisp")
#+end_src
Use use-package to use packages.
#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src
** UI and appearance
Start with empty scratch and show buffer name in frame.
#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
  (setq frame-title-format "%b")
#+end_src

Remove menu bar, scroll bar, and tool bar.
#+begin_src emacs-lisp
  (menu-bar-mode 0)
  (scroll-bar-mode 0)
  (tool-bar-mode 0)
#+end_src

Load theme and set font and set custom themes location.
#+begin_src emacs-lisp
  (use-package ample-theme  
    :ensure t
    :config (load-theme 'ample-flat t))

  (add-to-list 'default-frame-alist 
               '(font . "Iosevka-12"))

  (let ((basedir "~/.emacs.d/themes/"))
    (dolist (f (directory-files basedir))
      (if (and (not (or (equal f ".") (equal f "..")))
               (file-directory-p (concat basedir f)))
          (add-to-list 'custom-theme-load-path (concat basedir f)))))
#+end_src 
* Clean up
** Move some things out of the way
Backups to separate folder. And some settings for backups.
#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

  (setq delete-old-versions -1)
  (setq version-control t)
  (setq vc-make-backup-files t)
#+end_src
custom-set-variables to separate file
#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/customs.el")
  (load custom-file)
#+end_src
* Laptop or desktop
Based on screen resolution, check whether I'm using desktop or laptop. This information is used on some settings I like to be different between desktop and laptop.

My desktop screen resolutions is 1920x1080. Laptop is 1600x900. So, if screen height is greater than 900, I'm using desktop.
 
This is a work in progress, so far any settings aren't dependent on this.
#+begin_src emacs-lisp
  (defvar computer-type nil)
  (defun tsl/desktop-or-laptop ()
    "Based on screen resolution, define whether Emacs is opened on desktop or laptop."
    (interactive)
    (if (> (x-display-pixel-height) 900)
        (setq computer-type 'desktop)
      (setq computer-type 'laptop)))
  (tsl/desktop-or-laptop)
#+end_src
* Powerline
Powerline. Just because I've seen it, and it looked cool.
#+begin_src emacs-lisp
  (use-package powerline
    :ensure t)
  (powerline-vim-theme)
#+end_src
* Config files to register
Quick acces to config files by putting them to register. Access with: =C-x r j=
#+begin_src emacs-lisp
  (set-register ?e '(file . "~/.emacs.d/conf.org")) ; Emacs config
  (set-register ?i '(file . "~/.config/i3/config")) ; i3
#+end_src 
* Calendar in Finnish
Finnish day and month names, and week starts from Monday.
#+begin_src emacs-lisp
    (setq calendar-week-start-day 1
          calendar-day-name-array
          ["sunnuntai"
           "maanantai"
           "tiistai"
           "keskiviikko"
           "torstai"
           "perjantai"
           "lauantai"]
          calendar-month-name-array
          ["tammi" "helmi" "maalis" "huhti" "touko" 
           "kesä" "heinä" "elo" "syys"
           "loka" "marras" "joulu"]
          calendar-day-abbrev-array
          ["sun" "maa" "tii" "kes" "tor" "per" "lau"]
          calendar-day-header-array
          ["su" "ma" "ti" "ke" "to" "pe" "la"])
#+end_src 
* Windows and buffers
When splitting windows, switch to new one.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x 2") (lambda () (interactive) (split-window-below) (other-window 1)))
  (global-set-key (kbd "C-x 3") (lambda () (interactive) (split-window-right) (other-window 1)))
#+end_src
Use =window-numbering-mode=: Windows are numbered, M-number goes to wanted window.
#+begin_src emacs-lisp
  (use-package window-numbering
    :ensure t
    :config (window-numbering-mode 1))
#+end_src
Use ibuffer. Kill the current buffer without asking.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
  (defalias 'list-buffers 'ibuffer)
#+end_src
Some various commands
#+begin_src emacs-lisp
  (global-set-key (kbd "C-¨") 'save-buffer)
#+end_src
* Answer just y or n
Answer "y or n" instead "yes or no"
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src
* Abbrevs and visual-line-mode
Use =abbrev-mode= and =visual-line-mode= in org-mode to make writing more comfortable.

=abbrev-mode= makes typing easier by offering abbreviations for common words.

=visual-line-mode= wraps long lines on screen, making the experience more word processor like.
#+begin_src emacs-lisp
  (setq abbrev-file-name
        "~/.emacs.d/abbrevs")
  ; (setq-default abbrev-mode t)
  (add-hook 'org-mode-hook
            (lambda ()
              (visual-line-mode 1)
              (abbrev-mode 1)))
  (setq save-abbrevs t)
  #+end_src 
* Swiper and counsel
Use =swiper= and =counsel= for searching and stuff. Found =swiper= via [[http://cestlaz.github.io/posts/using-emacs-6-swiper/#.V3WeZnWLSUE][this video]].
#+begin_src emacs-lisp
  (use-package counsel
    :ensure t
    )

  (use-package swiper
    :ensure try
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    :bind (("\C-s" . swiper)
           ("C-c C-r" . ivy-resume)
           ("<f6>" . ivy-resume)
           ("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("<f1> f" . counsel-describe-function)
           ("<f1> v" . counsel-describe-variable)
           ("<f1> l" . counsel-load-library)
           ("<f2> i" . counsel-info-lookup-symbol)
           ("<f2> u" . counsel-unicode-char)
           ("C-c g" . counsel-git)
           ("C-c j" . counsel-git-grep)
           ("C-c k" . counsel-ag)
           ("C-x l" . counsel-locate)
           ("C-S-o" . counsel-rhythmbox)
           :map read-expression-map
           ("C-r" . counsel-expression-history)))
 #+end_src
* Helpful and which-key
=which-key= is a nice and helpful thing to have. After a prefix shows possible commands to use.
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :config (which-key-mode 1))
#+end_src

"[[https://github.com/Wilfred/helpful][Helpful]] is an alternative to the built-in Emacs help that provides much more contextual information."
#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :bind (("C-h f" . helpful-callable)
           ("C-h v" . helpful-variable)
           ("C-h k" . helpful-key)
           ("C-c C-." . helpful-at-point))
    :config (evil-define-key 'normal helpful-mode-map (kbd "q") 'quit-window))
#+end_src
* word-count
#+begin_src emacs-lisp
  (load "word-count")
#+end_src
* Lua mode
#+begin_src emacs-lisp
  (use-package lua-mode
    :ensure t
    :mode "\\.lua\\'")
  (use-package fountain-mode
    :ensure t
    :mode "\\.fountain\\'")
#+end_src
* Sentences end with one space
Why would anyone end sentences with two spaces?
This makes do-whatever-to-sentence commands work with my Finnish text with one space between sentences.
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src
* Scrolling
Hadn't even thought how annoying the default scrolling in Emacs was. This makes it better
#+begin_src emacs-lisp
  (setq scroll-step            1
	scroll-conservatively  10000)
#+end_src
* Misc configs
Keys for bigger and smaller text.
#+begin_src emacs-lisp
(bind-key "C-+" 'text-scale-increase)
(bind-key "C--" 'text-scale-decrease)
#+end_src

Transpose things with M-t
#+begin_src emacs-lisp
  (bind-key "M-t" nil) ;; which used to be transpose-words
  (bind-key "M-t l" 'transpose-lines)
  (bind-key "M-t w" 'transpose-words)
  (bind-key "M-t t" 'transpose-words)
  (bind-key "M-t M-t" 'transpose-words)
  (bind-key "M-t s" 'transpose-sexps)
#+end_src

Some aliases.
#+begin_src emacs-lisp
(defalias 'qrr 'query-replace-regexp)
(defalias 'qr 'query-replace)
(defalias 'rr 'replace-regexp)
(defalias 'plp 'package-list-packages)
#+end_src

Show parenthesis. This is good even for a non-programmer. And of course helps with working with elisp here in config.
#+begin_src emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0)
#+end_src

Functions to convert Spotify song links and Youtube links in file to embed code.
#+begin_src emacs-lisp
(defun tsl/spotify-links-to-embed ()
  "Convert Spotify song links to embed code."
  (interactive)
  (beginning-of-buffer)
  (while (re-search-forward "https:/+open\\.spotify\\.com/track/\\(.+\\)" nil t)
    (replace-match "<iframe src=\"https://embed.spotify.com/?uri=spotify%3Atrack%3A\\1\" width=\"100%\" height=\"100\" frameborder=\"0\" allowtransparency=\"true\"></iframe>" nil nil)))

(defun tsl/youtube-links-to-embed ()
  "Convert Youtube song links to embed code."
  (interactive)
  (beginning-of-buffer)
  (while (re-search-forward "^https:/+www\\.youtube\\.com/watch\\?v=\\(.+\\)" nil t) ; Only search for links in beginning of line to avoid replacing links in text.
    (replace-match "<iframe width=\"100%\" height=\"456\" src=\"https://www.youtube.com/embed/\\1\" frameborder=\"0\" allowfullscreen></iframe>" nil nil)))
#+end_src
* Misc packages
Install some packages.
#+begin_src emacs-lisp
  (use-package base16-theme
    :ensure t)
  (use-package palimpsest
    :ensure t)
  (use-package paredit
    :ensure t)
  (use-package rainbow-mode
    :ensure t)
  (use-package projectile
    :ensure t)
  (use-package key-chord
  :ensure t)
  (use-package counsel-projectile
  :ensure t)
#+end_src
* evil-mode and evil-org
After some time in Vim, Ranger, Qutebrowser, i3wm and other Vim-like programs, I geuss I have to start using =evil-mode=.
#+begin_src emacs-lisp
    (use-package evil
      :ensure t
      :init (setq evil-want-abbrev-expand-on-insert-exit nil)
      :config (evil-mode))

    (use-package evil-org
      :ensure t)

    (add-hook 'org-mode-hook
              (lambda ()
                (evil-org-mode)))
#+end_src

Some key stuff.

- =Enter= in normal mode:
  - Insert new line below current one, unless cursor on link
  - If cursor on link, open the link
- In insert mode =jj= does =Esc=
- Evil commands in =org-agenda=

#+begin_src emacs-lisp  
  (defun tsl/evil-insert-line-below-or-open-link ()
  "If cursor is on link, open the link with 'org-open-at-point. Otherwise insert new line under current one and return to evli-normal-state."
    (interactive)
    (if (and org-return-follows-link
             (or (org-in-regexp org-ts-regexp-both nil t)
                 (org-in-regexp org-tsr-regexp-both nil  t)
                 (org-in-regexp org-any-link-re nil t)))
        (call-interactively #'org-open-at-point)
      (evil-open-below nil)
      (evil-normal-state)))
  (define-key evil-normal-state-map [return] 'tsl/evil-insert-line-below-or-open-link)

  (setq key-chord-two-keys-delay 0.5)
  (key-chord-define evil-insert-state-map "jj" 'evil-normal-state)
  (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
  (key-chord-define evil-insert-state-map "öa" "\\")
  (key-chord-mode 1)

  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)
#+end_src

#+begin_src emacs-lisp
(defalias 'org-agenda-bulk-remove-all-marks 'org-agenda-bulk-unmark-all)
#+end_src
* general.el
I decided to go with [[https://github.com/noctuid/general.el][general.el]] for vim-like leader key functionality. And easier key command in general.

At this point there's not many keys set. I know some functions I want to have quick access to, but I don't know the keys to bind them yet.

Work in progress.
#+BEGIN_SRC emacs-lisp
  (use-package general
    :ensure t)

  (defun tsl/save-all ()
      (interactive)
    (save-some-buffers t))

  (general-define-key
                  :prefix "SPC"
                  :keymaps 'normal
                  "r" 'jump-to-register
                  "bb" 'switch-to-buffer
                  "bk" 'kill-this-buffer
                  "bc" 'clone-indirect-buffer-other-window
                  "ss" 'save-buffer
                  "sa" 'tsl/save-all
                  "t" 'org-todo
                  "q" 'evil-quit
                  "Q" 'save-buffers-kill-terminal
                  "d" 'org-cut-special
                  "y" 'org-copy-special
                  "p" 'org-paste-special
                  "ma" 'abbrev-mode
                  "ml" 'display-line-numbers-mode
                  "mp" 'electric-pair-mode
                  "fo" 'counsel-find-file
                  "fO" 'find-file-other-window
                  "u" 'undo-tree-visualize
                  "x" 'counsel-M-x
                  "cc" 'org-ctrl-c-ctrl-c 
                  "mm" (lambda () (interactive)(set-window-margins nil 60 60))
                  "mM" (lambda () (interactive)(set-window-margins nil nil nil))
                  "SPC a" 'org-agenda
                  "SPC f" 'bjm/elfeed-load-db-and-open
                  )
#+END_SRC
* Yasnippet
Yasnippet
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config (yas-global-mode 1))

  (use-package yasnippet-snippets
    :ensure t)
#+end_src
* Undo-tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :init (global-undo-tree-mode)
    :bind (("C-z" . undo)
    ("C-S-z" . undo-tree-redo)))
#+end_src
* Reload config file
Make a function to reload the config file.
#+begin_src emacs-lisp
(defun tsl/reload-settings ()
  (interactive)
  (org-babel-load-file "~/.emacs.d/conf.org"))
#+end_src
* Writing view
Split frame into two or three windows, indirect clone of current buffer to each.

This makes it possible to have actual text I'm working on in one window, and outline of the file, notes, or something else from the same file in another window.
#+begin_src emacs-lisp
  (defun tsl/writing-view-3-windows ()
    (interactive)
    (split-window-horizontally 167)
    (split-window-horizontally 70)
    (clone-indirect-buffer nil t)
    (clone-indirect-buffer nil t))

  (defun tsl/writing-view-2-windows ()
    (interactive)
    (split-window-horizontally 70)
    (clone-indirect-buffer nil t))
#+end_src
* Magit
#+begin_src emacs-lisp
(use-package magit
:ensure t)
(global-set-key (kbd "C-x g") 'magit-status)
#+end_src
* Ledger
I started using Ledger to keep up with my money and stuff. Ledger works well with Emacs.

Put ledger file to register for easy access and tell Emacs to start ledger-mode when opening ledger file.
#+begin_src emacs-lisp
  (use-package ledger-mode
    :ensure t
    :mode "\\.ledger\\'")

  (set-register ?l '(file . "~/Dropbox/ledger/my.ledger"))

#+end_src
* browser
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-xdg-open)
#+END_SRC
* Clean up modeline
Remove some minor-modes from modeline. No need to see these there.
#+begin_src emacs-lisp
  (diminish 'abbrev-mode)
  (diminish 'which-key-mode)
                                          ;  (diminish 'yas-minor-mode)
  (diminish 'visual-line-mode)
  (diminish 'evil-org-mode)
  (diminish 'undo-tree-mode)
  (diminish 'which-key-mode)
#+end_src
Rename some major modes to take less space on modeline. 
#+begin_src emacs-lisp
  (defmacro diminish-major-mode (mode-hook abbrev)
    `(add-hook ,mode-hook
               (lambda () (setq mode-name ,abbrev))))

  (diminish-major-mode 'emacs-lisp-mode-hook "el")
#+end_src
* Neotree and ibuffer-sidebar
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t)

  (use-package ibuffer-sidebar
    :ensure t)

  (defun tsl/sidebars-toggle ()
    "Toggle neotree and ibuffer-sidebar"
    (interactive)
    (neotree-toggle)
    (ibuffer-sidebar-toggle-sidebar))

  (setq evil-emacs-state-modes (delq 'ibuffer-mode evil-emacs-state-modes))
  (global-set-key [f8] 'tsl/sidebars-toggle)

  (evil-define-key 'normal neotree-mode-map (kbd "l") 'neotree-enter)
  (evil-define-key 'normal neotree-mode-map (kbd "SPC") 'neotree-quick-look)
  (evil-define-key 'normal neotree-mode-map (kbd "q") 'neotree-hide)
  (evil-define-key 'normal neotree-mode-map (kbd "RET") 'neotree-enter)
#+END_SRC
* Org
  Configuration for =org-mode=, which is the main reason why I use Emacs.
** Pretty org-mode
Use org-bullets, change the three period ellipsis to something else, and use org-indent-mode
#+begin_src emacs-lisp
  (use-package org-bullets
    :ensure t
    ; :init (setq org-bullets-bullet-list '("►" "◾" "◆"))
    ; :init (setq org-bullets-bullet-list '("●"))
    :init (setq org-bullets-bullet-list '("▶" "▷"))
    :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

   (setq org-ellipsis " ▼")
  (add-hook 'org-mode-hook
            (lambda ()
              (org-indent-mode 1)))
#+end_src
** Multiple line italics
Allow italizing and bolding multiple words, or even whole paragraph.
#+begin_src emacs-lisp
  (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\r\n,\"")
#+end_src
** Key bindings
Some random bindings
#+begin_src emacs-lisp
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
  (define-key org-mode-map (kbd "C-c e") #'org-table-edit-field)
#+end_src

Move easily between headings
#+begin_src emacs-lisp
  (with-eval-after-load 'org
   (define-key org-mode-map (kbd "M-p") #'outline-previous-visible-heading)
   (define-key org-mode-map (kbd "M-n") #'outline-next-visible-heading)
   (define-key org-mode-map (kbd "M-P") #'org-backward-heading-same-level)
   (define-key org-mode-map (kbd "M-N") #'org-forward-heading-same-level)
   (define-key org-mode-map (kbd "M-U") #'outline-up-heading))
#+end_src
** Capture anywhere
Make it possible to pop up a quick capture frame when not in Emacs. This is bound to a key command in my Awesome window manager.
Makes it possible to capture notes, tasks, whatever. Copied from [[http://cestlaz.github.io/posts/using-emacs-24-capture-2/#.WQmyab2LRhE][Mike Zamansky's blog and video]].
#+begin_src emacs-lisp
  (defadvice org-capture-finalize 
      (after delete-capture-frame activate)  
    "Advise capture-finalize to close the frame"  
    (if (equal "capture" (frame-parameter nil 'name))  
        (delete-frame)))

  (defadvice org-capture-destroy 
      (after delete-capture-frame activate)  
    "Advise capture-destroy to close the frame"  
    (if (equal "capture" (frame-parameter nil 'name))  
        (delete-frame)))  

  (use-package noflet
    :ensure t )
  (defun make-capture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "capture")))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
      (org-capture)))
#+end_src
** Org-agenda and TODO stuff
Set org-agenda files
#+begin_src emacs-lisp
  (setq org-agenda-files
        '("~/Dropbox/org/inbox.org"
          "~/Dropbox/org/tickler.org"
          "~/Dropbox/org/todo.org"))
#+end_src  

Put logs in LOGBOOK drawer.
#+begin_src emacs-lisp
  (setq org-log-into-drawer t)
#+end_src

Clock into CLOCKING drawer.
#+begin_src emacs-lisp
  (setq org-clock-into-drawer t)
#+end_src 

Set todo keyword sequences. These are in Finnish, because I'm Finnish.
Some files, for example the one with my blog texts, have different todo keyword sequences.
#+begin_src emacs-lisp
    (setq org-todo-keywords
               '((sequence "TODO(t)" "SEURAAVA(s)" "KESKEN(k)" "ODOTTAA(o@)" "|" "VALMIS(v!)" "PERUTTU(p@)")))
#+end_src

If the todo item has undone children todos or checkboxes, it can't be marked done.
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
(setq org-track-ordered-property-with-tag t)
(setq org-enforce-todo-checkbox-dependencies t)
#+end_src 

If I want TODO items automatically marked DONE when all the children are DONE, I uncomment this. At this point I don't want that.
#+begin_src emacs-lisp
;  (defun org-summary-todo (n-done n-not-done)
 ;   "Switch entry to DONE when all subentries are done, to TODO otherwise."
  ;  (let (org-log-done org-log-states)   ; turn off logging
   ;   (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

;  (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+end_src

I usually refile things between org-agenda files. But sometimes need to refile somewhere in current, non-agenda file, for example here in config.
Set =org-refile-targets= to include current file, agenda files, and bunch of other files (defined in =.emacs.secrets.el=)
#+begin_src emacs-lisp
  (setq org-refile-targets '((nil :maxlevel . 3)
                             (org-agenda-files :maxlevel . 3)
                             (tsl/refile-files :maxlevel . 3)
                             ))

  (setq org-refile-use-outline-path 'file
        org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src
** Agenda commands
#+begin_src emacs-lisp
    (setq org-agenda-custom-commands
          '(("n" "seuraavat ja kesken" todo "SEURAAVA|KESKEN"
             ((org-agenda-overriding-header "Kesken olevat ja projektien seuraavat")))

            ("b" "blogit" todo ""
             ((org-agenda-files '("~/Dropbox/org/blogit.org"))
              (org-agenda-overriding-header "Blogitekstit")))

            ("j" "joskus" todo ""
             ((org-agenda-files '("~/Dropbox/org/someday.org"))))

            ("d" "päivä"
             ((agenda "" ((org-agenda-span 1)
                          (org-agenda-overriding-header "Tänään")))
              (agenda "" ((org-agenda-span 1) (org-agenda-files '("~/Dropbox/org/raha.org"))
                          (org-agenda-overriding-header "Laskut")))
              (todo "KESKEN"
                    ((org-agenda-overriding-header "Kesken olevat")))
              (todo "SEURAAVA"
                    ((org-agenda-overriding-header "Projektien seuraavat")))
              (agenda "" ((org-agenda-span 1) (org-agenda-files '("~/Dropbox/org/media.org"))
                          (org-agenda-overriding-header "Media")))
              (agenda "" ((org-agenda-span 1) (org-agenda-files '("~/Dropbox/org/kirjasto.org"))
                          (org-agenda-overriding-header "Kirjasto")))))

            ("v" "viikko"
             ((agenda "" ((org-agenda-span 7)
                          (org-agenda-overriding-header "Tällä viikolla")))
              (todo "KESKEN"
                    ((org-agenda-overriding-header "Kesken olevat")))
              (todo "SEURAAVA"
                    ((org-agenda-overriding-header "Projektien seuraavat")))
              (agenda "" ((org-agenda-span 7) (org-agenda-files '("~/Dropbox/org/media.org"))
                          (org-agenda-overriding-header "Media")))))

            ("p" "projektit" tags-todo "proj")
            ))
                                            ; Keys reserved for built-in commands are:
                                            ; a t T m M s S L C e / ? < > * #
#+end_src

#+begin_src emacs-lisp
(setq org-agenda-block-separator ?▰)
#+end_src
** Inherited tags in agenda
Remove tag clutter from agenda view. Disabled for now.
#+begin_src emacs-lisp
 (setq org-agenda-show-inherited-tags t)
#+end_src
** Exporting
*** Export macros
This is for exporting and copying the result to clipboard, to be pasted to Blogger.

Export current subree, body only, in HTML to buffer. Select all, kill-region.
#+begin_src emacs-lisp
  (fset 'tsl/blog-export
	"\C-c\C-e\C-b\C-shH\C-xh\C-w\C-x0")
#+end_src
Export org file to ascii. 
#+begin_src emacs-lisp
  (fset 'tsl/ascii-export
	"\C-c\C-etA\C-xh\C-w\C-x0")
#+end_src
*** org-reveal
Export org files to [[https://github.com/hakimel/reveal.js/][reveal.js]]
#+begin_src emacs-lisp
  (use-package ox-reveal
    :ensure ox-reveal)

  (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
  (setq org-reveal-mathjax t)

  (use-package htmlize
    :ensure t)
#+end_src
*** Ascii exporting
When exporting to ASCII, I want the text to be clean as possible, so I can take it to another program (ie. Scribus or Google Drive) as raw text, and style it there. There are reasons for me needing to do this.

Following function does these things:
- set width of exported ascii text to the length of the longest line to avoid line breaks in paragraphs
- set empty lines around headlines and between paragraphs to 0
- don't indent the body text
- don't use any characters under headlines
#+begin_src emacs-lisp
;  (defun tsl/org-ascii-clean-text ()
;    (save-excursion (setq org-ascii-text-width
;                          (cadr (goto-longest-line (point-min) (point-max))))
;                          (setq org-ascii-headline-spacing '(0 . 0))
;                          (setq org-ascii-paragraph-spacing 0)
;                          (setq org-ascii-inner-margin 0)
;                          (setq org-ascii-underline '((ascii nil nil nil)
;			  (latin1 nil nil nil)
;			  (utf-8 nil nil nil nil nil)))))
#+end_src
Run the function when saving an org-mode buffer. This way the text width keeps up when the text changes.
#+begin_src emacs-lisp
;  (add-hook 'before-save-hook
;            (lambda () (if (eq major-mode 'org-mode)
;                           (tsl/org-ascii-clean-text))))
#+end_src
** Day lasts until 5 a.m.
In org-agenda next day starts at 5 a.m. instead of midnight, because I'm a vampire.
#+begin_src emacs-lisp
; (setq org-extend-today-until 5) 
#+end_src
** enter follows links
In org files, open links by pressing =Enter=
#+begin_src emacs-lisp
(setq org-return-follows-link t)
#+end_src
** Defalt appointment duration
If I don't set the ending time when scheduling appointments or whatever, the default duration is 60 minutes.
#+begin_src emacs-lisp
(setq org-agenda-default-appointment-duration 60)
#+end_src
** Create timestamp under heading
=org-schedule= and =org-deadline= create a timestamp right after the heading of the subtree, no matter where in the subtree the command is run. =org-timestamp= creates the timestamp at cursor position.

I want to use scheduling and deadlines as little as possible, and use simple timestamps to make my tasks appear in agenda instead. My tasks are often only a heading, so it's annoying to create a new line just for the timestamp.

This function is a quick fix for that. If run on a heading, it creates the timestamp under the heading. If run anywhere else, it creates the timestamp at cursor position as it normally would.

Probably not the fanciest fix, but so far it works.
#+begin_src emacs-lisp
  (defun tsl/org-timestamp ()
    (interactive)
    (if (org-at-heading-p)
        (progn (org-end-of-line)
               (org-return)
               (org-time-stamp nil)) 
      (org-time-stamp nil)))

(define-key org-mode-map (kbd "C-c .") 'tsl/org-timestamp)
#+end_src
** widths
#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup 'only-window)

(setq org-agenda-prefix-format
'((agenda . "%-10:c%-12t% s")
 (todo . "%-12:c%-12t")
 (tags . "%-12:c")
 (search . "%-12:c")))

(setq org-agenda-scheduled-leaders '("Sch: " "Sch.%2dx"))
(setq org-agenda-deadline-leaders '("DL: " "In.%3d: " "%2d ago: "))
#+END_SRC 
* elfeed
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure t
    :config (setq elfeed-db-directory "~/Dropbox/.elfeed/db")
    (setq-default elfeed-search-filter "@6-months-old +unread ")
    (evil-define-key 'normal elfeed-search-mode-map
      "o" 'elfeed-search-browse-url
      "m" 'elfeed-search-untag-all-unread
      "M" 'elfeed-mark-all-as-read
      "u" 'elfeed-search-tag-all-unread
      "U" 'elfeed-mark-all-as-unread
      "O" 'elfeed-search-show-entry
      "q" 'elfeed-search-quit-window
      "y" 'elfeed-search-yank
      "s" 'elfeed-search-live-filter
      "S" 'elfeed-search-set-filter
      "r" 'elfeed-search-update--force
      "w" 'elfeed-search-tag-all-wl
      "W" 'elfeed-search-untag-all-wl
      "R" 'elfeed-search-fetch
      "f" 'hydra-elfeed-tags/body)
    (evil-define-key 'normal elfeed-show-mode-map
      "o" 'elfeed-show-visit
      "q" 'elfeed-kill-buffer
      "n" 'elfeed-goodies/split-show-next
      "p" 'elfeed-goodies/split-show-prev
      "y" 'elfeed-show-yank
      ))

  (custom-set-faces
   '(elfeed-search-unread-title-face
     ((t :foreground "#a9df90")))
   '(elfeed-search-title-face
     ((t :foreground "#857575")))
   )

  (defhydra hydra-elfeed-tags (:exit t)
    "filter"
    ("y" (elfeed-search-set-filter "@6-months-ago +unread +yt ") "youtube")
    ("r" (elfeed-search-set-filter "@6-months-ago +unread +reddit ") "reddit")
    ("b" (elfeed-search-set-filter "@6-months-ago +unread +blog ") "blogit")
    ("c" (elfeed-search-set-filter "@6-months-ago +unread +comic ") "sarjakuvat")
    ("u" (elfeed-search-set-filter "@6-months-ago +unread +news +fi ") "uutiset, fi")
    ("n" (elfeed-search-set-filter "@6-months-ago +unread +news +en ") "uutiset, en")
    ("s" (call-interactively 'tsl/elfeed-set-filter-to-selected) "selected entry")
    ("f" (elfeed-search-set-filter nil) "default")
    )

  (defun elfeed-mark-all-as-read ()
    (interactive)
    (mark-whole-buffer)
    (elfeed-search-untag-all-unread))

  (defun elfeed-mark-all-as-unread ()
    (interactive)
    (mark-whole-buffer)
    (elfeed-search-tag-all-unread))

  (defun elfeed-search-tag-all-wl ()
    (interactive)
    (elfeed-search-tag-all 'wl))

  (defun elfeed-search-untag-all-wl ()
    (interactive)
    (elfeed-search-untag-all 'wl))

  (use-package elfeed-goodies
    :ensure t
    :config (elfeed-goodies/setup))

  (defun bjm/elfeed-load-db-and-open ()
    "Wrapper to load the elfeed db from disk before opening"
    (interactive)
    (elfeed-db-load)
    (elfeed)
    (elfeed-search-update--force))

  (defun tsl/elfeed-set-filter-to-selected (entry)
    "Set elfeed filter to tags of the selected entry."
    (interactive (list (elfeed-search-selected :ignore-region)))
    (when (elfeed-entry-p entry)
      (let ((tags-list (elfeed-entry-tags entry))
            (tags-string "@6-months-ago "))
        (while tags-list
          (setq tags-string (concat tags-string "+" (format "%s" (car tags-list)) " "))
          (setq tags-list (cdr tags-list)))
        (elfeed-search-set-filter tags-string))))

  (use-package elfeed-org
    :ensure t
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/Dropbox/.elfeed/elfeed.org")))
#+END_SRC
* License
[[https://www.gnu.org/licenses/gpl-3.0.en.html][GNU General Public License]]
* Deprecated and unused
This section includes settings I don't need anymore, at least right now. Or thing's I've copied from somwhere but didn't use after all.

I'm re-organizing my config file, mostly becuase starting to use evil-mode change things quite a lot. evil-mode also makes some things unnecessary. So I'm moving them here, cause I don't want to get rid of them (yet), just in case.
** Invoke =M-x= without the Alt key
Copied from: https://github.com/bradwright/emacs.d. Althoug, at this point I decided to leave the old =M-x= in use as well.

As per [[https://sites.google.com/site/steveyegge2/effective-emacs#item2][Yegge's Item 2]]. This unmaps the difficult =M-x= (usually =Alt+x=) to =C-x
m=, and then add a fat-finger combination of =C-x C-m=:

#+begin_src emacs-lisp :tangle no
  (global-unset-key (kbd "C-x m"))
;  (global-unset-key (kbd "M-x"))
  (global-set-key (kbd "C-x m") 'execute-extended-command)
  (global-set-key (kbd "C-x C-m") 'execute-extended-command)
#+end_src
** Kill (and save) line or region
Copy active region with =M-w=. If there's no active region, =M-w= copy /the whole line/.
Found in: [[https://www.emacswiki.org/emacs/WholeLineOrRegion][Emacs wiki]]
#+begin_src emacs-lisp :tangle no
  (defun copy-region-or-whole-line (beg end flash)
    (interactive (if (use-region-p)
		     (list (region-beginning) (region-end) nil)
		   (list (line-beginning-position)
			 (line-beginning-position 2) 'flash)))
    (kill-ring-save beg end)
    (when flash
      (save-excursion
	((if ) (equal (current-column) 0)
	 (goto-char end)
	 (goto-char beg))
	(sit-for blink-matching-delay))))
  (global-set-key [remap kill-ring-save] 'copy-region-or-whole-line)
#+end_src

Cut (kill)the active region with =C-k=. If theres no active region, cut /the rest of the line/.

Needs some fixing to work with org-mode, cause org-mode has its own =org-kill-line=
#+begin_src emacs-lisp :tangle no
  (defun cut-region-or-line ()
    (interactive (if (use-region-p)
		     (kill-region (region-beginning) (region-end))
		   (kill-line nil))))
  (global-set-key [remap kill-line] 'cut-region-or-line)
  #+end_src

I want a bar cursor instead of the default block one. I also want current line highlighted.
#+begin_src emacs-lisp :tangle no
  (global-hl-line-mode 1)
  (set-default 'cursor-type 'bar)
#+end_src
** Save buffer when focus is lost                                :disabled:
#+begin_src emacs-lisp :tangle no
 (use-package focus-autosave-mode
   :ensure t
   :init (focus-autosave-mode)
   :diminish focus-autosave-mode)
#+end_src
** Save place in files                                           :disabled:
#+begin_src emacs-lisp :tangle no
 (use-package saveplace
   :init (save-place-mode 1)
   :config
   (progn
     (setq-default save-place t)
     (setq-default save-place-file (expand-file-name "places" user-cache-directory))))
#+end_src
** Update parent heading cookie                                  :disabled:
Found here: https://github.com/magnars/.emacs.d
Renamed to my function namespace
#+begin_src emacs-lisp :tangle no
 (defun tsl/update-parent-cookie ()
  (when (equal major-mode 'org-mode)
    (save-excursion
      (ignore-errors
        (org-back-to-heading)
        (org-update-parent-todo-statistics)))))
#+end_src
** Better return for org                                         :disabled:
Pressing =enter= adds "new items to lists, new headings after a heading, and new rows to tables. In each case, a double return on an empty item, headline or table row will delete that line, and terminate the list, headlines or table." Copied from [[http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/][here]]. 

Disabled for now. Didn't work quite as I expected. Will look into this later.
#+begin_src emacs-lisp :tangle no
  (require 'org-inlinetask)
  (defun tsl/org-return (&optional ignore)
    "Add new list item, heading or table row with RET.
  A double return on an empty element deletes it.
  Use a prefix arg to get regular RET. "
    (interactive "P")
    (if ignore
        (org-return)
      (cond

       ((eq 'line-break (car (org-element-context)))
        (org-return-indent))

       ;; Open links like usual, unless point is at the end of a line.
       ;; and if at beginning of line, just press enter.
       ((or (and (eq 'link (car (org-element-context))) (not (eolp)))
            (bolp))
        (org-return))

       ;; It doesn't make sense to add headings in inline tasks. Thanks Anders
       ;; Johansson!
       ((org-inlinetask-in-task-p)
        (org-return))

       ;; checkboxes too
       ((org-at-item-checkbox-p)
        (org-insert-todo-heading nil))

       ;; lists end with two blank lines, so we need to make sure we are also not
       ;; at the beginning of a line to avoid a loop where a new entry gets
       ;; created with only one blank line.
       ((org-in-item-p)
        (if (save-excursion (beginning-of-line) (org-element-property :contents-begin (org-element-context)))
            (org-insert-heading)
          (beginning-of-line)
          (delete-region (line-beginning-position) (line-end-position))
          (org-return)))

       ;; org-heading
       ((org-at-heading-p)
        (if (not (string= "" (org-element-property :title (org-element-context))))
            (progn (org-end-of-meta-data)
                   (org-insert-heading-respect-content)
                   (outline-show-entry))
          (beginning-of-line)
          (setf (buffer-substring
                 (line-beginning-position) (line-end-position)) "")))

       ;; tables
       ((org-at-table-p)
        (if (-any?
             (lambda (x) (not (string= "" x)))
             (nth
              (- (org-table-current-dline) 1)
              (org-table-to-lisp)))
            (org-return)
          ;; empty row
          (beginning-of-line)
          (setf (buffer-substring
                 (line-beginning-position) (line-end-position)) "")
          (org-return)))

       ;; fall-through case
       (t
        (org-return)))))


  (define-key org-mode-map (kbd "RET")
    'tsl/org-return)
#+end_src
